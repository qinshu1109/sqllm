// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"
	"log"
	"net/http"
	"sub2api/internal/config"
	"sub2api/internal/handler"
	"sub2api/internal/handler/admin"
	"sub2api/internal/infrastructure"
	"sub2api/internal/repository"
	"sub2api/internal/server"
	"sub2api/internal/service"
	"time"
)

import (
	_ "embed"
)

// Injectors from wire.go:

func initializeApplication(buildInfo handler.BuildInfo) (*Application, error) {
	configConfig, err := config.ProvideConfig()
	if err != nil {
		return nil, err
	}
	db, err := infrastructure.ProvideDB(configConfig)
	if err != nil {
		return nil, err
	}
	userRepository := repository.NewUserRepository(db)
	settingRepository := repository.NewSettingRepository(db)
	settingService := service.NewSettingService(settingRepository, configConfig)
	client := infrastructure.ProvideRedis(configConfig)
	emailCache := repository.NewEmailCache(client)
	emailService := service.NewEmailService(settingRepository, emailCache)
	turnstileService := service.NewTurnstileService(settingService)
	emailQueueService := service.ProvideEmailQueueService(emailService)
	authService := service.NewAuthService(userRepository, configConfig, settingService, emailService, turnstileService, emailQueueService)
	authHandler := handler.NewAuthHandler(authService)
	userService := service.NewUserService(userRepository, configConfig)
	userHandler := handler.NewUserHandler(userService)
	apiKeyRepository := repository.NewApiKeyRepository(db)
	groupRepository := repository.NewGroupRepository(db)
	userSubscriptionRepository := repository.NewUserSubscriptionRepository(db)
	apiKeyCache := repository.NewApiKeyCache(client)
	apiKeyService := service.NewApiKeyService(apiKeyRepository, userRepository, groupRepository, userSubscriptionRepository, apiKeyCache, configConfig)
	apiKeyHandler := handler.NewAPIKeyHandler(apiKeyService)
	usageLogRepository := repository.NewUsageLogRepository(db)
	usageService := service.NewUsageService(usageLogRepository, userRepository)
	usageHandler := handler.NewUsageHandler(usageService, usageLogRepository, apiKeyService)
	redeemCodeRepository := repository.NewRedeemCodeRepository(db)
	billingCache := repository.NewBillingCache(client)
	billingCacheService := service.NewBillingCacheService(billingCache, userRepository, userSubscriptionRepository)
	subscriptionService := service.NewSubscriptionService(groupRepository, userSubscriptionRepository, billingCacheService)
	redeemCache := repository.NewRedeemCache(client)
	redeemService := service.NewRedeemService(redeemCodeRepository, userRepository, subscriptionService, redeemCache, billingCacheService)
	redeemHandler := handler.NewRedeemHandler(redeemService)
	subscriptionHandler := handler.NewSubscriptionHandler(subscriptionService)
	accountRepository := repository.NewAccountRepository(db)
	proxyRepository := repository.NewProxyRepository(db)
	adminService := service.NewAdminService(userRepository, groupRepository, accountRepository, proxyRepository, apiKeyRepository, redeemCodeRepository, usageLogRepository, userSubscriptionRepository, billingCacheService)
	dashboardHandler := admin.NewDashboardHandler(adminService, usageLogRepository)
	adminUserHandler := admin.NewUserHandler(adminService)
	groupHandler := admin.NewGroupHandler(adminService)
	oAuthService := service.NewOAuthService(proxyRepository)
	rateLimitService := service.NewRateLimitService(accountRepository, configConfig)
	accountUsageService := service.NewAccountUsageService(accountRepository, usageLogRepository, oAuthService)
	accountTestService := service.NewAccountTestService(accountRepository, oAuthService)
	accountHandler := admin.NewAccountHandler(adminService, oAuthService, rateLimitService, accountUsageService, accountTestService)
	oAuthHandler := admin.NewOAuthHandler(oAuthService, adminService)
	proxyHandler := admin.NewProxyHandler(adminService)
	adminRedeemHandler := admin.NewRedeemHandler(adminService)
	settingHandler := admin.NewSettingHandler(settingService, emailService)
	systemHandler := handler.ProvideSystemHandler(client, buildInfo)
	adminSubscriptionHandler := admin.NewSubscriptionHandler(subscriptionService)
	adminUsageHandler := admin.NewUsageHandler(usageLogRepository, apiKeyRepository, usageService, adminService)
	adminHandlers := handler.ProvideAdminHandlers(dashboardHandler, adminUserHandler, groupHandler, accountHandler, oAuthHandler, proxyHandler, adminRedeemHandler, settingHandler, systemHandler, adminSubscriptionHandler, adminUsageHandler)
	gatewayCache := repository.NewGatewayCache(client)
	pricingService, err := service.ProvidePricingService(configConfig)
	if err != nil {
		return nil, err
	}
	billingService := service.NewBillingService(configConfig, pricingService)
	identityCache := repository.NewIdentityCache(client)
	identityService := service.NewIdentityService(identityCache)
	gatewayService := service.NewGatewayService(accountRepository, usageLogRepository, userRepository, userSubscriptionRepository, gatewayCache, configConfig, oAuthService, billingService, rateLimitService, billingCacheService, identityService)
	concurrencyCache := repository.NewConcurrencyCache(client)
	concurrencyService := service.NewConcurrencyService(concurrencyCache)
	gatewayHandler := handler.NewGatewayHandler(gatewayService, userService, concurrencyService, billingCacheService)
	handlerSettingHandler := handler.ProvideSettingHandler(settingService, buildInfo)
	handlers := handler.ProvideHandlers(authHandler, userHandler, apiKeyHandler, usageHandler, redeemHandler, subscriptionHandler, adminHandlers, gatewayHandler, handlerSettingHandler)
	groupService := service.NewGroupService(groupRepository)
	accountService := service.NewAccountService(accountRepository, groupRepository)
	proxyService := service.NewProxyService(proxyRepository)
	services := &service.Services{
		Auth:         authService,
		User:         userService,
		ApiKey:       apiKeyService,
		Group:        groupService,
		Account:      accountService,
		Proxy:        proxyService,
		Redeem:       redeemService,
		Usage:        usageService,
		Pricing:      pricingService,
		Billing:      billingService,
		BillingCache: billingCacheService,
		Admin:        adminService,
		Gateway:      gatewayService,
		OAuth:        oAuthService,
		RateLimit:    rateLimitService,
		AccountUsage: accountUsageService,
		AccountTest:  accountTestService,
		Setting:      settingService,
		Email:        emailService,
		EmailQueue:   emailQueueService,
		Turnstile:    turnstileService,
		Subscription: subscriptionService,
		Concurrency:  concurrencyService,
		Identity:     identityService,
	}
	repositories := &repository.Repositories{
		User:             userRepository,
		ApiKey:           apiKeyRepository,
		Group:            groupRepository,
		Account:          accountRepository,
		Proxy:            proxyRepository,
		RedeemCode:       redeemCodeRepository,
		UsageLog:         usageLogRepository,
		Setting:          settingRepository,
		UserSubscription: userSubscriptionRepository,
	}
	engine := server.ProvideRouter(configConfig, handlers, services, repositories)
	httpServer := server.ProvideHTTPServer(configConfig, engine)
	v := provideCleanup(db, client, services)
	application := &Application{
		Server:  httpServer,
		Cleanup: v,
	}
	return application, nil
}

// wire.go:

type Application struct {
	Server  *http.Server
	Cleanup func()
}

func provideCleanup(
	db *gorm.DB,
	rdb *redis.Client,
	services *service.Services,
) func() {
	return func() {
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		cleanupSteps := []struct {
			name string
			fn   func() error
		}{
			{"PricingService", func() error {
				services.Pricing.Stop()
				return nil
			}},
			{"EmailQueueService", func() error {
				services.EmailQueue.Stop()
				return nil
			}},
			{"Redis", func() error {
				return rdb.Close()
			}},
			{"Database", func() error {
				sqlDB, err := db.DB()
				if err != nil {
					return err
				}
				return sqlDB.Close()
			}},
		}

		for _, step := range cleanupSteps {
			if err := step.fn(); err != nil {
				log.Printf("[Cleanup] %s failed: %v", step.name, err)

			} else {
				log.Printf("[Cleanup] %s succeeded", step.name)
			}
		}

		select {
		case <-ctx.Done():
			log.Printf("[Cleanup] Warning: cleanup timed out after 10 seconds")
		default:
			log.Printf("[Cleanup] All cleanup steps completed")
		}
	}
}
